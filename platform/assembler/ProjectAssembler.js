// platform/assembler/ProjectAssembler.js
const path = require('path');
const BackendGenerator = require('./generators/BackendGenerator');
const FrontendGenerator = require('./generators/FrontendGenerator');

class ProjectAssembler {
  constructor(brickRepo, outputPath) {
    this.brickRepo = brickRepo;
    this.outputPath = outputPath;
    this.backendGenerator = new BackendGenerator(brickRepo);
    this.frontendGenerator = new FrontendGenerator(brickRepo);
  }

  async assemble(projectId, sdf) {
    const outputDir = path.join(this.outputPath, projectId);
    const backendDir = path.join(outputDir, 'backend');
    const frontendDir = path.join(outputDir, 'frontend');

    console.log(`Starting assembly for project ${projectId} at ${outputDir}`);

    try {
      // ==================== BACKEND ====================
      console.log('Generating backend...');
      await this.backendGenerator.scaffold(backendDir, projectId);
      // Pass global module config to generators (e.g., activity log defaults)
      if (typeof this.backendGenerator.setModules === 'function') {
        this.backendGenerator.setModules((sdf && sdf.modules) || {});
      }

      const userEntities = sdf.entities && Array.isArray(sdf.entities) ? sdf.entities : [];
      const backendEntities = this._withSystemEntities(userEntities, sdf);

      if (backendEntities.length) {
        for (const entity of backendEntities) {
          console.log(`  - Entity: ${entity.slug}`);
          // Pass the full schema so the backend generator can enforce cross-entity rules
          // (e.g., reference integrity / delete restrictions).
          await this.backendGenerator.generateEntity(backendDir, entity, backendEntities);
        }
        await this.backendGenerator.generateRoutesIndex(backendDir, backendEntities);
      }

      await this.backendGenerator.generateMainEntry(backendDir);
      await this._applyBackendRuntimeModules(backendDir, sdf, backendEntities);

      // ==================== FRONTEND ====================
      console.log('Generating frontend...');
      await this.frontendGenerator.scaffold(frontendDir, sdf);

      if (userEntities.length) {
        // Generate DynamicForm component (shared)
        await this.frontendGenerator.generateDynamicForm(frontendDir);

        // Generate entity pages
        for (const entity of userEntities) {
          console.log(`  - Page: ${entity.slug}`);
          // Pass the FULL list of entities so the generator can resolve relationships (e.g. category_id -> categories)
          await this.frontendGenerator.generateEntityPage(frontendDir, entity, userEntities, sdf);
        }

        // Generate App with routes
        await this.frontendGenerator.generateApp(frontendDir, userEntities, sdf);

        // Generate Sidebar with links
        await this.frontendGenerator.generateSidebar(frontendDir, userEntities, sdf);
      }

      // ==================== ROOT FILES ====================
      await this._generateRootFiles(outputDir, projectId);

      console.log('Assembly complete.');
      return outputDir;
    } catch (error) {
      console.error('Assembly failed:', error);
      throw error;
    }
  }

  async _generateRootFiles(outputDir, projectId) {
    const fs = require('fs').promises;

    // Root docker-compose.yml
    const dockerCompose = `version: '3.8'
services:
  backend:
    build: ./backend
    ports:
      - "3000:3000"
    volumes:
      - ./backend/data:/app/data
    environment:
      - PORT=3000

  frontend:
    build: ./frontend
    ports:
      - "5173:5173"
    environment:
      - VITE_API_URL=http://localhost:3000/api
    depends_on:
      - backend
`;
    await fs.writeFile(path.join(outputDir, 'docker-compose.yml'), dockerCompose);

    // Root README
    const readme = `# ${projectId}

This ERP was automatically generated by CustomERP.

## Quick Start

### Windows (PowerShell)
\`\`\`powershell
.\\dev.ps1 start
\`\`\`

### Linux/macOS
\`\`\`bash
chmod +x dev.sh
./dev.sh start
\`\`\`

- Backend API: http://localhost:3000
- Frontend: http://localhost:5173

## Commands

- \`start\`: Build and start containers
- \`stop\`: Stop containers
- \`logs\`: View live logs
- \`clean\`: Remove containers and volumes
`;
    await fs.writeFile(path.join(outputDir, 'README.md'), readme);

    // Development Scripts
    // NOTE: Kept for backward-compat; templates are loaded via brickRepo.
    const templateEngine = require('./TemplateEngine'); // Require locally if not passed

    try {
      const devShTemplate = await this.brickRepo.getTemplate('dev.sh.template');
      const devPs1Template = await this.brickRepo.getTemplate('dev.ps1.template');

      const devSh = devShTemplate.replace(/\{\{projectId\}\}/g, projectId);
      const devPs1 = devPs1Template.replace(/\{\{projectId\}\}/g, projectId);

      await fs.writeFile(path.join(outputDir, 'dev.sh'), devSh);
      await fs.writeFile(path.join(outputDir, 'dev.ps1'), devPs1);

      // Make shell script executable (on Unix-like systems)
      try {
        await fs.chmod(path.join(outputDir, 'dev.sh'), '755');
      } catch (e) {
        // Ignore on Windows
      }
    } catch (e) {
      console.warn('Warning: Could not generate dev scripts', e);
    }
  }

  _withSystemEntities(userEntities, sdf) {
    const entities = Array.isArray(userEntities) ? [...userEntities] : [];
    const modules = (sdf && sdf.modules) ? sdf.modules : {};

    const wantsActivityLog =
      modules?.activity_log?.enabled === true ||
      entities.some((e) => e && e.features && e.features.audit_trail);

    const wantsScheduledReports = modules?.scheduled_reports?.enabled === true;
    const reportsSlug =
      (modules?.scheduled_reports && (modules.scheduled_reports.target_slug || modules.scheduled_reports.targetSlug)) ||
      '__reports';

    if (wantsActivityLog && !entities.some((e) => e && e.slug === '__audit_logs')) {
      entities.push({
        slug: '__audit_logs',
        display_name: 'Audit Logs',
        display_field: 'at',
        system: { hidden: true },
        ui: { search: true, csv_import: false, csv_export: false, print: false },
        list: { columns: ['at', 'action', 'entity', 'entity_id', 'message'] },
        fields: [
          { name: 'at', type: 'string', label: 'At', required: true },
          { name: 'action', type: 'string', label: 'Action', required: true },
          { name: 'entity', type: 'string', label: 'Entity', required: true },
          { name: 'entity_id', type: 'string', label: 'Entity ID', required: false },
          { name: 'message', type: 'string', label: 'Message', required: false },
          { name: 'meta', type: 'text', label: 'Meta', required: false },
        ],
        features: {},
      });
    }

    if (wantsScheduledReports && !entities.some((e) => e && e.slug === reportsSlug)) {
      entities.push({
        slug: reportsSlug,
        display_name: 'Reports',
        display_field: 'report_date',
        system: { hidden: true },
        ui: { search: true, csv_import: false, csv_export: false, print: false },
        list: { columns: ['report_date', 'report_type'] },
        fields: [
          { name: 'report_date', type: 'string', label: 'Report Date', required: true },
          { name: 'report_type', type: 'string', label: 'Report Type', required: true },
          { name: 'generated_at', type: 'string', label: 'Generated At', required: true },
          { name: 'data', type: 'text', label: 'Data (JSON)', required: false },
        ],
        features: {},
      });
    }

    return entities;
  }

  async _applyBackendRuntimeModules(backendDir, sdf, backendEntities) {
    const fs = require('fs').promises;
    const path = require('path');

    const modules = (sdf && sdf.modules) ? sdf.modules : {};
    const scheduled = modules?.scheduled_reports || {};

    // Generate optional runtime config for the backend entrypoint (scheduler, etc.)
    const systemConfig = {
      modules: {
        scheduled_reports: {
          enabled: scheduled.enabled === true,
          cron: scheduled.cron || '0 0 * * *',
          target_slug: scheduled.target_slug || '__reports',
          report_type: scheduled.report_type || 'daily_summary',
          entities: Array.isArray(scheduled.entities) ? scheduled.entities : [],
          low_stock: scheduled.low_stock || scheduled.lowStock || null,
          expiry: scheduled.expiry || null,
          inventory_value:
            scheduled.inventory_value ||
            scheduled.inventoryValue ||
            scheduled.valuation ||
            scheduled.inventory_valuation ||
            null,
          movements:
            scheduled.movements ||
            scheduled.movement_summary ||
            scheduled.movementSummary ||
            null,
          entity_snapshots:
            (Array.isArray(scheduled.entity_snapshots) ? scheduled.entity_snapshots : null) ||
            (Array.isArray(scheduled.entitySnapshots) ? scheduled.entitySnapshots : []) ||
            [],
        },
      },
    };

    const shouldWriteConfig =
      systemConfig.modules.scheduled_reports.enabled === true;

    if (shouldWriteConfig) {
      await fs.writeFile(
        path.join(backendDir, 'src/systemConfig.js'),
        'module.exports = ' + JSON.stringify(systemConfig, null, 2) + ';\n'
      );

      // Ensure dependency exists
      const pkgPath = path.join(backendDir, 'package.json');
      const pkgRaw = await fs.readFile(pkgPath, 'utf8');
      const pkg = JSON.parse(pkgRaw);
      pkg.dependencies = pkg.dependencies || {};
      if (!pkg.dependencies['node-cron']) {
        pkg.dependencies['node-cron'] = '^3.0.3';
      }
      await fs.writeFile(pkgPath, JSON.stringify(pkg, null, 2));
    }

    // Silence unused param lint in this file (kept for future modules)
    void backendEntities;
  }
}

module.exports = ProjectAssembler;
