// platform/backend/src/assembler/ProjectAssembler.js
const path = require('path');
const BackendGenerator = require('./generators/BackendGenerator');
const FrontendGenerator = require('./generators/FrontendGenerator');

class ProjectAssembler {
  constructor(brickRepo, outputPath) {
    this.brickRepo = brickRepo;
    this.outputPath = outputPath;
    this.backendGenerator = new BackendGenerator(brickRepo);
    this.frontendGenerator = new FrontendGenerator(brickRepo);
  }

  async assemble(projectId, sdf) {
    const outputDir = path.join(this.outputPath, projectId);
    const backendDir = path.join(outputDir, 'backend');
    const frontendDir = path.join(outputDir, 'frontend');
    
    console.log(`Starting assembly for project ${projectId} at ${outputDir}`);

    try {
      // ==================== BACKEND ====================
      console.log('Generating backend...');
      await this.backendGenerator.scaffold(backendDir, projectId);

      if (sdf.entities && Array.isArray(sdf.entities)) {
        for (const entity of sdf.entities) {
          console.log(`  - Entity: ${entity.slug}`);
          await this.backendGenerator.generateEntity(backendDir, entity);
        }
        await this.backendGenerator.generateRoutesIndex(backendDir, sdf.entities);
      }

      await this.backendGenerator.generateMainEntry(backendDir);

      // ==================== FRONTEND ====================
      console.log('Generating frontend...');
      await this.frontendGenerator.scaffold(frontendDir);

      if (sdf.entities && Array.isArray(sdf.entities)) {
        // Generate DynamicForm component (shared)
        await this.frontendGenerator.generateDynamicForm(frontendDir);
        
        // Generate entity pages
        for (const entity of sdf.entities) {
          console.log(`  - Page: ${entity.slug}`);
          // Pass the FULL list of entities so the generator can resolve relationships (e.g. category_id -> categories)
          await this.frontendGenerator.generateEntityPage(frontendDir, entity, sdf.entities);
        }
        
        // Generate App with routes
        await this.frontendGenerator.generateApp(frontendDir, sdf.entities);
        
        // Generate Sidebar with links
        await this.frontendGenerator.generateSidebar(frontendDir, sdf.entities);
      }

      // ==================== ROOT FILES ====================
      await this._generateRootFiles(outputDir, projectId);

      console.log('Assembly complete.');
      return outputDir;
    } catch (error) {
      console.error('Assembly failed:', error);
      throw error;
    }
  }

  async _generateRootFiles(outputDir, projectId) {
    const fs = require('fs').promises;

    // Root docker-compose.yml
    const dockerCompose = `version: '3.8'
services:
  backend:
    build: ./backend
    ports:
      - "3000:3000"
    volumes:
      - ./backend/data:/app/data
    environment:
      - PORT=3000

  frontend:
    build: ./frontend
    ports:
      - "5173:5173"
    environment:
      - VITE_API_URL=http://localhost:3000/api
    depends_on:
      - backend
`;
    await fs.writeFile(path.join(outputDir, 'docker-compose.yml'), dockerCompose);

    // Root README
    const readme = `# ${projectId}

This ERP was automatically generated by CustomERP.

## Quick Start

### Windows (PowerShell)
\`\`\`powershell
.\\dev.ps1 start
\`\`\`

### Linux/macOS
\`\`\`bash
chmod +x dev.sh
./dev.sh start
\`\`\`

- Backend API: http://localhost:3000
- Frontend: http://localhost:5173

## Commands

- \`start\`: Build and start containers
- \`stop\`: Stop containers
- \`logs\`: View live logs
- \`clean\`: Remove containers and volumes
`;
    await fs.writeFile(path.join(outputDir, 'README.md'), readme);

    // Development Scripts
    const templateEngine = require('./TemplateEngine'); // Require locally if not passed
    // NOTE: In a real refactor, we should pass templateEngine or use this.brickRepo
    
    // We need to read the templates. Since we are inside ProjectAssembler, we can use this.brickRepo
    try {
        const devShTemplate = await this.brickRepo.getTemplate('dev.sh.template');
        const devPs1Template = await this.brickRepo.getTemplate('dev.ps1.template');
        
        // Simple replace for projectId
        // Note: TemplateEngine class is static, so we can use it if imported, 
        // or just use string replace since we might not have imported it in this file
        const context = { projectId };
        
        const devSh = devShTemplate.replace(/\{\{projectId\}\}/g, projectId);
        const devPs1 = devPs1Template.replace(/\{\{projectId\}\}/g, projectId);

        await fs.writeFile(path.join(outputDir, 'dev.sh'), devSh);
        await fs.writeFile(path.join(outputDir, 'dev.ps1'), devPs1);
        
        // Make shell script executable (on Unix-like systems)
        try {
            await fs.chmod(path.join(outputDir, 'dev.sh'), '755');
        } catch (e) {
            // Ignore on Windows
        }
    } catch (e) {
        console.warn('Warning: Could not generate dev scripts', e);
    }
  }
}

module.exports = ProjectAssembler;
